いきなり非同期
##############

進化のバトンタッチ
******************

　ハードウェアの進化に合わせてソフトウェアは進化します。
CPUのクロック周波数が限界に近づき１つのマシンに複数のCPUやコアが搭載されるようになりました。
ハードウェアがこのような進化を辿るとソフトウェアの進化にも影響が出ます。
それが **非同期処理** です。
ソフトウェアの出す命令が **連続する必要があるかどうか** についてはソフトウェア自身にしか判りません。
そのため様々なプログラム言語が非同期処理を実装しやすいよう進化しています。

プロセス外から攻める
********************

　Linux系のサーバであればシェルスクリプト経由でプロセスが起動できます。
起動されたプロセス内での非同期処理を検討する前にシェルスクリプトによる非同期起動を候補に加えたいものです。
苦労してプログラムを改修したが、結果的に複数プロセスの同時起動で済む話だったなんてことは避けましょう。
::

    out() { echo ERR-$1 1>&2 && sleep 1 && echo OUT-$1; } && export -f out

実験用に関数を定義します。
引数を１つ取り、それを含む文字列を標準エラー出力し、１秒待ってから標準出力するシンプルな関数です。
::

    seq 1 18 | xargs -P 12 -I% bash -c 'out %'

適当な数値を生成し ``xargs`` で関数を非同期起動します。
``-P`` オプションで同時実行の最大数を制御します。
``-I`` オプションで引数の位置を決めるとともに **引数の数を１つに固定** します。

出力に溺れないために
********************

　人類の進化はハードウェアやソフトウェアの進化には全く歯が立ちません。
処理が速くなったと喜んだのも束の間で標準エラー出力を見逃して足下をすくわれるというケースも少なくありません。
非同期起動の出力でも異常を検出できるよう設計しましょう。
::

    exe() { seq 1 18 | xargs -P 12 -I% bash -c 'out %'; } && export -f exe

実験用に関数を追加で定義します。内容は先程の非同期起動そのものです。
::

    # コンソールに全ての出力を表示する
    { exe | tee OUT.log; } 3>&1 1>&2 2>&3 | tee ERR.log

    # コンソールに標準エラー出力だけを表示する
    { exe >     OUT.log; } 3>&1 1>&2 2>&3 | tee ERR.log

標準出力と標準エラー出力を別々のログファイルに書き出した上でコンソールの表示を調整します。
ポイントは ``tee`` コマンドが常に **標準出力** をファイルに書き出す点です。
``{ }`` で囲むことで関数自体の標準出力に対する操作までを１つのコマンドに見立てます。
ファイルディスクリプタの ``3`` をダミーで生成しておき、標準出力と標準エラー出力を入れ替えて対処します。
